## 虚拟DOM

虚拟DOM是把真实DOM使用对象的方式表达，一个对象元素又通过类型，属性，子元素三部分来表示。虚拟DOM又放在内存中，并与实际的DOM保持同步。

## React Diff 算法

传统diff算法的复杂度为O(n ^3),显然是无法满足性能要求的。React通过制定大胆的策略，将O(n^3)复杂度的问题转换成O(n)复杂度的问题。

## Diff 策略

1. Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。
2. 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。
3. 对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。

基于以上三个前提策略，React 分别对 tree diff、component diff 以及 element diff 进行算法优化，事实也证明这三个前提策略是合理且准确的，它保证了整体界面构建的性能。



基于策略1，React 对树的算法进行了简洁明了的优化，即对树进行分层比较，两棵树只会对同一层次的节点进行比较。

> 既然 DOM 节点跨层级的移动操作少到可以忽略不计，react就只会对相同颜色方框内的同一层级的 DOM 节点进行比较，如果两个节点的类型不同，那么就直接删除老的节点再插入新节点。即同一个父节点下的所有子节点，当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较，如果子节点存在但是顺序不一样了，react就会根据DOM中key的顺序就删除或新增。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。

![](C:\Users\Administrator\Desktop\0c08dbb6b1e0745780de4d208ad51d34_r.jpg)

**如果出现了 DOM 节点跨层级的移动操作，React diff 会有怎样的表现呢**？

如下图，A 节点（包括其子节点）整个被移动到 D 节点下，由于 React 只会简单的考虑同层级节点的位置变换，**而对于不同层级的节点，只有创建和删除操作**。当根节点发现子节点中 A 消失了，就会直接销毁 A；当 D 发现多了一个子节点 A，则会创建新的 A（包括子节点）作为其子节点。此时，React diff 的执行情况：**create A -> create B -> create C -> delete A**。

![](C:\Users\Administrator\Desktop\d712a73769688afe1ef1a055391d99ed_r.png)

由此可发现，当出现节点跨层级移动时，并不会出现想象中的移动操作，而是以 A 为根节点的树被整个重新创建，这是一种影响 React 性能的操作，因此 **React 官方建议不要进行 DOM 节点跨层级的操作**。



来源：https://zhuanlan.zhihu.com/p/20346379，https://juejin.cn/post/6844903806132568072

