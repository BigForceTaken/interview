## 强缓存和协商缓存

参考：https://juejin.cn/post/6844903737538920462

我们习惯将缓存分为**强缓存**和**协商缓存**两种。两者的主要区别是使用本地缓存的时候，是否需要向服务器验证本地缓存是否依旧有效。顾名思义，协商缓存，就是需要和服务器进行协商，最终确定是否使用本地缓存。

### 强缓存

强缓存主要使用Expires、Cache-Control 两个头字段，**两者同时存在Cache-Control 优先级更高**。当命中强缓存的时候，客户端不会再求，直接从缓存中读取内容，并返回HTTP状态码200。

- Expires

  响应头，代表该资源的过期时间。是一个GMT 格式的标准时间。当客户端请求服务器的时候，服务器会返回资源的同时还会带上响应头Expires，表示资源的过期具体时间，如果客户端在过期时间之前再次获取该资源，就不需要再请求我服务器了，可以直接在缓存里面拿。Expire是HTTP1.0标准下的字段。

  **缺点**：缓存时间到期后，浏览器不管文件是否有变化都会向服务器请求资源，还有一个明显的缺点就是设置的到期时间依据的是客户端的本地时间，如果我把本地系统时间手动修改的话，也会影响浏览器的判断。

- Cache-Control

  为了让强缓存更精确，HTTP1.1增加了Cache-Control字段。Cache-Control既能出现在请求头又能出现在响应头，其不同的值代表不同的意思

  Cache-Control 服务端参数：

  - max-age: 在多少秒内有效，是一个相对时间，这样比Expires具体的时间就更精确了。
  - s-maxage: 就是用于表示 cache 服务器上（比如 cache CDN，缓存代理服务器）的缓存的有效时间的，并只对 public 缓存有效。
  - no-cache：不使用本地强缓存。需要使用缓存协商。
  - no-store：直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。
  - public：可以被所有的用户缓存，包括终端用户和中间代理服务器。
  - private：只能被终端用户的浏览器缓存，不允许中间缓存代理进行缓存，默认的。

  Cache-Control 客户端参数：

  - max-stale: 5 表示客户端到代理服务器上拿缓存的时候，即使代理缓存过期了也不要紧，只要过期时间在 5 秒之内，还是可以从代理中获取的。
  - min-fresh: 5 表示代理缓存需要一定的新鲜度，不要等到缓存刚好到期再拿，一定要在到期前 5 秒之前的时间拿，否则拿不到。
  - only-if-cached 这个字段加上后表示客户端只会接受代理缓存，而不会接受源服务器的响应。如果代理缓存无效，则直接返回 504（Gateway Timeout）。

  一般，我们会设置Cache-Control的值为“public, max-age=xxx”，表示在xxx秒内再次访问该资源，均使用本地的缓存，不再向服务器发起请求。

  **我们可以看到使用强制缓存后，如果浏览器在获取资源时命中了强制缓存，这个时候我们服务端已经更新了的话，用户就不能访问到新的资源了，这就太不科学了。**所以协商缓存出现了。

## 协商缓存

协商缓存主要有四个头字段，它们两两组合配合使用，If-Modified-Since 和 Last-Modified一组，Etag 和 If-None-Match一组，当同时存在的时候会以Etag 和 If-None-Match为主。当命中协商缓存的时候，服务器会返回HTTP状态码304，让客户端直接从本地缓存里面读取文件。

- If-Modified-Since

  请求头，资源最近修改时间，由浏览器告诉服务器。其实就是第一次访问服务端返回的Last-Modified的值。

- Last-Modified

  响应头，资源最近修改时间，由服务器告诉浏览器。

- Etag

  响应头，资源标识，由服务器告诉浏览器。

- If-None-Match

  请求头，缓存资源标识，由浏览器告诉服务器。其实就是第一次访问服务端返回的Etag的值。

#### If-Modified-Since 和 Last-Modified

当客户端第一次请求服务器的时候，服务端会返回一个Last-Modified响应头，该字段是一个标准时间。客户端请求服务器的时候会带上If-Modified-Since请求头字段，该字段的值就是服务器返回的Last-Modified的值。服务器接收到请求后会比较这两个值是否一样，一样就返回304，让客户端从缓存中读取，不一样就会返回新文件给客户端并更新Last-Modified响应头字段的值。

使用这两个字段的协商缓存也还有缺点：如果同一秒浏览器来请求资源，同一时间资源也被修改了，那么浏览器有可能是获取的旧的资源文件，而不能获取到新文件。

#### Etag 和 If-None-Match

为了解决文件修改时间只能精确到秒带来的问题，我们引入 Etag 响应头。Etag 是由文件修改时间与文件大小计算而成，只有当文件文件内容或修改时间变了Etag的值才会发生变化。当客户端第一次请求服务器的时候，服务端会返回一个Etag响应头。客户端请求服务器的时候会带上If-None-Match请求头字段，该字段的值就是服务器返回的Etag的值。服务器接收到请求后会比较这两个值是否一样，一样就返回304，让客户端从缓存中读取，不一样就会返回新文件给客户端并更新Etag响应头字段的值。

### 使用强缓存和协商缓存的缺点

强缓存的问题点在于：如果命中了，那么浏览器是不会去请求服务器了，如果这个时候服务器文件改变了，那么客户端使用的还是旧文件，显然使用强缓存是不合理的。而协商缓存虽然能解决文件更新的问题，但是每次都要去访问一下服务器缓存的有效性，这种效率也是欠佳的。

### 前端缓存的最佳实践

缓存的意义就在于减少请求，更多地使用本地的资源，给用户更好的体验的同时，也减轻服务器压力。所以，最佳实践，就应该是尽可能命中强缓存，同时，能在更新版本的时候让客户端的缓存失效。综上所述，我们可以得出一个合理的缓存方案：

1. HTML使用协商缓存
2. css和js ，图片等，使用强缓存，并且文件名带上hash值

### 哈希值的分类

webpack给我们提供了三种哈希值计算方式，分别是hash、chunkhash和contenthash。那么这三者有什么区别呢？

- hash：跟整个项目的构建相关，构建生成的文件hash值都是一样的，只要项目里有文件更改，整个项目构建的hash值都会更改。
- chunkhash：根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk，生成对应的hash值。
- contenthash：由文件内容产生的hash值，内容不同产生的contenthash值也不一样。

显然，我们是不会使用第一种的。改了一个文件，打包之后，其他文件的hash都变了，缓存自然都失效了。这不是我们想要的。

那chunkhash和contenthash的主要应用场景是什么呢？在实际在项目中，我们一般会把项目中的css都抽离出对应的css文件来加以引用。如果我们使用chunkhash，当我们改了css代码之后，会发现css文件hash值改变的同时，js文件的hash值也会改变。这时候，contenthash就派上用场了。

## 总结

在做前端缓存时，我们尽可能设置长时间的强缓存，通过文件名加hash的方式来做版本更新。在代码分包的时候，应该将一些不常变的公共库独立打包出来，使其能够更持久的缓存。